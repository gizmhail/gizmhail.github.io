<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Gizmhail's blog - VR</title><link href="blog.poivre.name/" rel="alternate"></link><link href="blog.poivre.name/feeds/vr.atom.xml" rel="self"></link><id>blog.poivre.name/</id><updated>2021-02-06T23:30:00+01:00</updated><entry><title>Débuter en réalité virtuelle avec Unity et Oculus Quest - Système de grab “from scratch” (partie 4)</title><link href="blog.poivre.name/oculus-quest-vr-intro-4.html" rel="alternate"></link><published>2021-02-06T23:30:00+01:00</published><updated>2021-02-06T23:30:00+01:00</updated><author><name>Gizmhail</name></author><id>tag:None,2021-02-06:blog.poivre.name/oculus-quest-vr-intro-4.html</id><summary type="html">&lt;p&gt;Dans un projet en réalité virtuelle, comme abordé en &lt;a href="blog.poivre.name/oculus-quest-vr-intro-2.html"&gt;partie 2&lt;/a&gt;, une partie critique est la stack d'interaction : comment gérer le fait d’attraper des objets, se déplacer/téléporter, avoir des pointeurs, interagir avec l’UI, animer les mains, …&lt;/p&gt;
&lt;p&gt;Il est courant dans un projet de s’appuyer sur une …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Dans un projet en réalité virtuelle, comme abordé en &lt;a href="blog.poivre.name/oculus-quest-vr-intro-2.html"&gt;partie 2&lt;/a&gt;, une partie critique est la stack d'interaction : comment gérer le fait d’attraper des objets, se déplacer/téléporter, avoir des pointeurs, interagir avec l’UI, animer les mains, …&lt;/p&gt;
&lt;p&gt;Il est courant dans un projet de s’appuyer sur une stack existante (VRTK, XRInteraction toolkit, …) ou une stack fournie par un constructeur spécifique en accompagnement de ses couches basses de détection de casque (Sample Framework dans Oculus Integration, SteamVR Interaction System dans SteamVR,  …)&lt;/p&gt;
&lt;p&gt;Cependant, à la fois pour la curiosité, mais aussi pour bien arriver à maîtriser ces stacks, il est intéressant de faire une fois “à la main” ces composants, au moins dans leur version naïve, pour comprendre les enjeux liés au moteur Unity, et pouvoir plus facilement debugger. C’est également utile plus tard dans la courbe de progression, si on commence à vouloir s’orienter vers des choses plus fines, car ces stacks peuvent limiter vos capacités en ayant trop “en dur” certains choix (autoriser ou non d’attraper plusieurs objets à la fois dans une même main, d’attraper à 2 mains, d’attraper main déjà fermée, de permettre à la physique d’interagir avec les mains et les objets tenus, …).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Néanmoins, si cela vous semble trop compliqué/abstrait pour le moment, n’hésitez pas à ignorer cette partie complètement : le but est plus d’attiser la curiosité que d’effrayer, et il est tout à fait possible de commencer à faire une application VR sans comprendre ce qu’on aborde ici. &lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;Choix sur l’interaction attendue&lt;/h1&gt;
&lt;p&gt;Nous allons donc voir ici comment très naïvement permettre avec juste les composants de base d’attraper en VR des objets (faire un “&lt;em&gt;grab&lt;/em&gt;”).&lt;/p&gt;
&lt;p&gt;Concernant les choix d'interaction, j’ai fait une sélection dans l’idée d’arriver au code le plus simple possible tout en gardant quelque chose d’utilisable réellement :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on veut pouvoir attraper librement un objet, pas sur une position précise&lt;/li&gt;
&lt;li&gt;si on attrape un objet avec une seconde main, il change de main (et on force l’utilisateur à arrêter de fermer la première main avant qu’elle ne puisse ré-attrapper, pour éviter une bataille de main :) )&lt;/li&gt;
&lt;li&gt;on ne permet donc pas d’attraper un objet à deux mains simultanément (pour le scaler, l’orienter, ou autre)&lt;/li&gt;
&lt;li&gt;une main ne peut attraper qu’un objet à la fois&lt;/li&gt;
&lt;li&gt;on ne tente pas de gérer avec le moteur physique les mains, ni les objets pendant qu’on les tient&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Avec ces choix, on peut uniquement se concentrer sur la base de la physique d’un “&lt;em&gt;grab&lt;/em&gt;”.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Remarque : Il y a de TRÈS nombreuses manières pertinentes de faire un grab, celle exposée ici n’est ni la plus élégante, ni le plus “puissante” (donnant le plus de possibilités), elle est vraiment essentiellement exposée à titre éducatif, n’hésitez pas à vous en éloigner fortement.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Physique d’un grab&lt;/h1&gt;
&lt;p&gt;Un &lt;em&gt;grab&lt;/em&gt; se décompose en :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;détecter qu’une main (le &lt;em&gt;grabber&lt;/em&gt;) est sur un objet attrapable (&lt;em&gt;grabbable&lt;/em&gt;) à attraper (en &lt;em&gt;hover&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;pendant que la main est en &lt;em&gt;hover&lt;/em&gt;, si on appuie sur le bouton de &lt;em&gt;grab&lt;/em&gt;, considérer le &lt;em&gt;grabbable&lt;/em&gt; comme attrapé&lt;/li&gt;
&lt;li&gt;tant qu’il est attrappé, forcer le &lt;em&gt;grabbable&lt;/em&gt; à suivre le &lt;em&gt;grabber&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;lorsque le bouton est lâché, déverrouiller le &lt;em&gt;grabbable&lt;/em&gt; et arrêter le suivi&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Configuration des mains&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;J’explique le pourquoi de la configuration des mains dans ce long chapitre, mais si le sujet vous effraye/ennuie, la conclusion en est simple, et directement utilisable :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mettre un RigidBody sur l’objet représentant la main, le mettre en mode isKinematics&lt;/li&gt;
&lt;li&gt;mettre un Collider (quelconque : BoxCollider, …) sur la main, le mettre en mode isTrigger&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Version longue&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Unity permet facilement de gérer les collisions, mais aussi les chevauchements. Il propose de donner une forme détectable pour cela aux objets (pas nécessairement liée à leur forme graphique).&lt;/p&gt;
&lt;p&gt;Ces &lt;em&gt;colliders&lt;/em&gt; permettent 2 choses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;de détecter des collisions : 2 objets qui se touchent et vont potentiellement (suivant leur configuration) bouger de par les forces liées à ce contact, via le moteur physique d’Unity&lt;/li&gt;
&lt;li&gt;de déclencher un message de chevauchement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A côté de cela, suivant que l’on veuille ou non qu’un objet soit pris en compte dans les forces gérées par le moteur physique, il est possible de mettre un composant &lt;em&gt;RigidBody&lt;/em&gt; en plus sur un objet.&lt;/p&gt;
&lt;p&gt;Pour finir de faire le tour de nos options, il est aussi possible de dire au Rigidbody que nous gérerons la position de l’objet par script (il ne sera plus déplacé par les collisions, les articulations, …) mais qu’il “causera” tout de même des forces aux autres : ces objets pilotés à la main ont l’option “&lt;em&gt;isKinematics&lt;/em&gt;” sur leur &lt;em&gt;RigidBody&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Nos choix soulignant que l’on ne veut pas gérer la physique, et que l’on s’intéresse à des chevauchements mais pas à des collisions, la sélection a faire semblerait être de ne mettre que des colliders, sans rigid body.&lt;/p&gt;
&lt;p&gt;Le souci est que les callback d’Unity ne nous arriveront pas si on ne fait que cela.&lt;/p&gt;
&lt;p&gt;Si vous voulez creuser ce sujet, une  page de la documentation d’Unity explique dans quels cas les callbacks sont déclenchés, et souligne aussi la philosophie derrière cela et les différents cas que l’on a décrit avant. Dès que l’on commence à faire des choses un peu avancées avec Unity, elle est à garder dans ses bookmarks :) : &lt;a href="https://docs.unity3d.com/Manual/CollidersOverview.html"&gt;https://docs.unity3d.com/Manual/CollidersOverview.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Donc, chaque main va devoir avoir un &lt;em&gt;RigidBody&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Mais, on compte la déplacer via script (lié à la position physique des contrôleurs hardware), donc il faut qu’il soit en mode &lt;em&gt;isKinematics&lt;/em&gt;: nous sommes en contrôle de la position.&lt;/p&gt;
&lt;p&gt;N’étant pas intéressé par déclencher des collisions (il devient difficile d’attraper des objets si on les pousse en approchant la main), nos &lt;em&gt;colliders&lt;/em&gt; de mains seront en mode &lt;em&gt;isTrigger&lt;/em&gt; : on ne fait que détecter les chevauchements.&lt;/p&gt;
&lt;p&gt;Avec cette configuration des mains, on pourra détecter des objets à attraper dans différentes configurations de leur côté (avec ou sans &lt;em&gt;RigidBody&lt;/em&gt;, avec des collider en mode &lt;em&gt;isTrigger&lt;/em&gt; ou non).&lt;/p&gt;
&lt;h1&gt;Position relative des objets&lt;/h1&gt;
&lt;p&gt;Une fois un objet attrapé, il doit suivre la main.&lt;/p&gt;
&lt;p&gt;Un des choix possible (et souvent adapté) aurait été de dire que quand on attrappe un objet, celui-ci se loge automatiquement au centre de la main. A partir de la, suivre la main pour le &lt;em&gt;grabbable&lt;/em&gt; aurait juste été prendre la position et la rotation de la main.&lt;/p&gt;
&lt;p&gt;Mais ici, on veut pouvoir attrapper naturellement un objet, donc n’importe où, sans effet de magnétisation au creux de la main, de &lt;em&gt;snap&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Il faut donc enregistrer le décalage par rapport au centre de la main au moment du grab, et appliquer ensuite en permanence ce décalage lors du suivi.&lt;/p&gt;
&lt;p&gt;Pour la position, Unity propose des méthodes pour trouver les coordonnées relatives par rapport à un référentiel d’un point en coordonnées globales :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pour enregistrer le décalage de position, en coordonnées relative donc : &lt;em&gt;InverseTransformPoint&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;pour appliquer un décalage et obtenir de nouveau des coordonnées globales : &lt;em&gt;TransformPoint&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pour la rotation, le fait qu’elle soit exprimée en Quaternion (pour résumer/simplifier : des matrices que l’on peut multiplier pour cumuler les rotations qu’elles représentent) dans Unity permet par calcul sur ceux-ci d’obtenir directement ce que l’on veut :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pour enregistrer le décalage de position : R&lt;sub&gt;décalage&lt;/sub&gt; = R&lt;sub&gt;référentiel&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt; x R&lt;sub&gt;grabbable&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;pour appliquer un décalage et obtenir de nouveau des coordonnées globales : R&lt;sub&gt;grabbable&lt;/sub&gt; = R&lt;sub&gt;référentiel&lt;/sub&gt; x R&lt;sub&gt;décalage&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&amp;lt;optionnel&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Remarque sur le calcul&lt;/em&gt; :&lt;/p&gt;
&lt;p&gt;Pour mieux les comprendre/mémoriser, il vaut mieux commencer par lire le calcul pour ré-appliquer le décalage sauvé. R&lt;sub&gt;grabbable&lt;/sub&gt; = R&lt;sub&gt;référentiel&lt;/sub&gt; * R&lt;sub&gt;décalage&lt;/sub&gt; revient juste à dire qu’une rotation en absolu est obtenue en prenant la rotation d’un référentiel, et en y ajoutant la rotation relative à ce référentiel.&lt;/p&gt;
&lt;p&gt;Le calcul pour obtenir comment sauver le décalage en découle directement. En effet, si on prend cette première expression, et qu’on multiplie à gauche chaque membre de l’égalité par R&lt;sub&gt;référentiel&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;,  (R&lt;sub&gt;référentiel&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt; x R&lt;sub&gt;référentiel&lt;/sub&gt;) devient la matrice identité et disparaît, nous donnant la formule finale.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;lt;/optionnel&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Code&lt;/h1&gt;
&lt;p&gt;Une fois ces 2 points durs traités, le code le plus naïf répondant à nos choix est assez simple, vous pourrez le trouver ci-dessous.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grabber&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine.InputSystem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;IGrabbable&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Grabber&lt;/span&gt; &lt;span class="n"&gt;CurrentGrabber&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;IsGrabbed&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;get&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGrab&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Grabber&lt;/span&gt; &lt;span class="n"&gt;newGrabber&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnUngrab&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="na"&gt;[RequireComponent(typeof(Rigidbody))]&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Grabber&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;InputAction&lt;/span&gt; &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isGrabbing&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Rigidbody&lt;/span&gt; &lt;span class="n"&gt;rigidBody&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;IGrabbable&lt;/span&gt; &lt;span class="n"&gt;grabbedObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Awake&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// Input action&lt;/span&gt;
        &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;performed&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;OnGrabStart&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;canceled&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;OnGrabEnd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Enable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="c1"&gt;// Rigidbody settings&lt;/span&gt;
        &lt;span class="n"&gt;rigidBody&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetComponent&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Rigidbody&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class="n"&gt;rigidBody&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isKinematic&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Our controller is driven by IRL inputs, and hence cannot be driven by engine physics&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cp"&gt;#region Input action callabcks&lt;/span&gt;
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGrabStart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CallbackContext&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isGrabbing&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGrabEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CallbackContext&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isGrabbing&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cp"&gt;#endregion&lt;/span&gt;

    &lt;span class="cp"&gt;#region Collision handling&lt;/span&gt;
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnTriggerStay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Collider&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grabbedObject&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// It is already the grabbed object or another, but we don&amp;#39;t allow shared grabbing here&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// Note: in real life exemple, we should not GetComponent on each Stay, for performance issues&lt;/span&gt;
        &lt;span class="c1"&gt;// A more relevant implementation would require to store a list of hovered colliders and matching IGrabbables,&lt;/span&gt;
        &lt;span class="c1"&gt;//  detected during OnTriggerEnter&lt;/span&gt;
        &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;grabbable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetComponent&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Grabbable&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grabbable&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;isGrabbing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grabbable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsGrabbed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// Force hand swap&lt;/span&gt;
                &lt;span class="n"&gt;grabbable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnUngrab&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;grabbable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnGrab&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;grabbedObject&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grabbable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cp"&gt;#endregion&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grabbedObject&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isGrabbing&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;grabbedObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IsGrabbed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// Object released by this hand&lt;/span&gt;
            &lt;span class="n"&gt;grabbedObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnUngrab&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grabbedObject&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;grabbedObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CurrentGrabber&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// Hand swap&lt;/span&gt;
            &lt;span class="n"&gt;grabbedObject&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// We force isGrabbing a flase to avoid this hand to catch any object again while it has not be opened and closed again&lt;/span&gt;
            &lt;span class="n"&gt;isGrabbing&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Grabbable&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;System.Collections&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;System.Collections.Generic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Grabbable&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IGrabbable&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Grabber&lt;/span&gt; &lt;span class="n"&gt;grabber&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Vector3&lt;/span&gt; &lt;span class="n"&gt;positionOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Quaternion&lt;/span&gt; &lt;span class="n"&gt;rotationOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="cp"&gt;#region IGrabbable&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;IsGrabbed&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;grabber&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Grabber&lt;/span&gt; &lt;span class="n"&gt;CurrentGrabber&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;grabber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGrab&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Grabber&lt;/span&gt; &lt;span class="n"&gt;newGrabber&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;grabber&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrabber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="c1"&gt;// Find grabbable position/rotation in grabber referential&lt;/span&gt;
        &lt;span class="n"&gt;positionOffset&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newGrabber&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InverseTransformPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;rotationOffset&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Quaternion&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newGrabber&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt; &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnUngrab&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;grabber&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cp"&gt;#endregion&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;IsGrabbed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="c1"&gt;// Follow grabber, adding position/rotation offsets&lt;/span&gt;
        &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grabber&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TransformPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;positionOffset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;grabber&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotation&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt; &lt;span class="n"&gt;rotationOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Mise en place&lt;/h1&gt;
&lt;p&gt;En repartant de ce qu’on avait partie 2, il faut ici :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ajouter un composant &lt;em&gt;Grabber&lt;/em&gt; sur les objets représentant chaque main&lt;/li&gt;
&lt;li&gt;cocher &lt;em&gt;isKinematics&lt;/em&gt; sur le &lt;em&gt;RigidBody&lt;/em&gt; qui s’est ajouté sur les mains (le script &lt;em&gt;Grabber&lt;/em&gt; le fait aussi si vous oubliez)&lt;/li&gt;
&lt;li&gt;ajouter un collider en mode &lt;em&gt;isTrigger&lt;/em&gt; sur les mains (le plus rapide : ajouter un cube, passer en &lt;em&gt;isTrigger&lt;/em&gt; son &lt;em&gt;BoxCollider&lt;/em&gt;, et réduire sa taille, par exemple à 0.05/0.05/0.05)&lt;/li&gt;
&lt;li&gt;créer des objets à manipuler, ayant un collider, et leur ajouter le script &lt;em&gt;Grabbable&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Remarque : gestion physique du &lt;em&gt;grabbable&lt;/em&gt; une fois relâché&lt;/h1&gt;
&lt;p&gt;Si jamais le &lt;em&gt;grabbable&lt;/em&gt; que l’on attrape est sensible aux forces “en temps normal” (quand il n’est pas tenu en main), donc avec un rigodBody et pas en mode &lt;em&gt;isKinematics&lt;/em&gt;, il faudra penser à la mettre en &lt;em&gt;isKinematics&lt;/em&gt; tant qu’il est tenu en main (et le remettre dans son état initial une fois relaché).&lt;/p&gt;
&lt;p&gt;En effet, comme dans l’implémentation de suivi qu’on a fait ici, on modifie manuellement sa position, le laisser subir en même temps les forces du moteur physiques arriverait à un résultat incohérent.&lt;/p&gt;
&lt;p&gt;Il est bien sûr possible d'implémenter un mode de suivi lui permettant de respecter sa gestion des forces physiques.&lt;/p&gt;
&lt;p&gt;XRInteraction Toolkit, en version preview pour le moment mais réalisé par Unity, propose par exemple un mode de suivi (velocity tracking) permettant cela.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/gizmhail/gizmhail.github.io/issues/4"&gt;Accès aux commentaires&lt;/a&gt;&lt;/strong&gt;
&lt;style&gt;
sub {
   font-size:80%;
   vertical-align:sub;
}
sup {
   font-size:80%;
   vertical-align:super;
&lt;/style&gt;&lt;/p&gt;</content><category term="VR"></category><category term="Oculus Quest"></category><category term="VR"></category><category term="XR"></category><category term="Tutorial"></category><category term="Development"></category><category term="Oculus quest Dev Intro"></category></entry><entry><title>Débuter en réalité virtuelle avec Unity et Oculus Quest - builder pour le casque en autonome (partie 3)</title><link href="blog.poivre.name/oculus-quest-vr-intro-3.html" rel="alternate"></link><published>2021-01-22T22:00:00+01:00</published><updated>2021-01-22T22:00:00+01:00</updated><author><name>Gizmhail</name></author><id>tag:None,2021-01-22:blog.poivre.name/oculus-quest-vr-intro-3.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Si jamais vous voulez cibler une application Windows pour casque PC cette partie ne vous est pas utile.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Même pour des app Oculus Quest, tant que vous ne voulez pas tester sur le casque en autonome (ie. sans être branché au PC), la suite est optionnelle pour développer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Vous en …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Si jamais vous voulez cibler une application Windows pour casque PC cette partie ne vous est pas utile.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Même pour des app Oculus Quest, tant que vous ne voulez pas tester sur le casque en autonome (ie. sans être branché au PC), la suite est optionnelle pour développer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Vous en aurez néanmoins besoin assez vite, à minima pour voir si votre application est assez performante. Sans parler du plaisir de la voir tourner, “pour de vrai” :)&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Préparation du build Android&lt;/h1&gt;
&lt;p&gt;Si vous ne l’avez pas fait à l’installation d’Unity, il faudra pour builder vers le casque avoir installé les modules Android. Dans Unity Hub, sur l’installation d’Unity qui vous intéresse, faites Add modules, et il faut à la fois cocher “Android build support”, ainsi qu’en dessous “Android SDK &amp;amp; NDK Tools” et “OpenJDK”&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Edit &amp;gt; Project settings &amp;gt; Player&lt;ul&gt;
&lt;li&gt;Choisir l’onglet Android&lt;/li&gt;
&lt;li&gt;Minimum API level : API Level 23&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Edit &amp;gt; Project Settings &amp;gt; XR Plug-in management &amp;gt; Oculus&lt;ul&gt;
&lt;li&gt;Passer Strereo Rendering mode en “Multiview”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build settings&lt;ul&gt;
&lt;li&gt;Platform : choisir Android&lt;/li&gt;
&lt;li&gt;Texture compression ASTC :&lt;/li&gt;
&lt;li&gt;Switch platform&lt;/li&gt;
&lt;li&gt;pensez à faire “Add open scenes” avec les scènes à livrer dans le build&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pour améliorer le rendu et les performance de votre application, suivez les conseils de la section “Define Quality settigns” de cette page &lt;a href="https://developer.oculus.com/documentation/unity/unity-conf-settings/?device=QUEST#set-quality-options"&gt;https://developer.oculus.com/documentation/unity/unity-conf-settings/?device=QUEST#set-quality-options&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;à minima, il faut dans Edit &amp;gt; Project Settings &amp;gt; Quality, sélectionez la qualité de votre build Android (medium par défaut), et mettre 4x pour l’antialiasing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Remarque 1 : pour optimiser vos réglages, cet article rentre plus dans le détail des options nécessaires : &lt;a href="https://developer.oculus.com/blog/tech-note-unity-settings-for-mobile-vr/"&gt;https://developer.oculus.com/blog/tech-note-unity-settings-for-mobile-vr/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Remarque 2 : Dans les versions précédentes d’Unity, pour pouvoir cibler la target Android, il fallait installer Android Studio. Cela peut toujours être intéressant pour du debbugage. Pour plus d’info sur l’ancienne procédure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.oculus.com/documentation/native/android/mobile-studio-setup-android/"&gt;https://developer.oculus.com/documentation/native/android/mobile-studio-setup-android/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/inborn-experience/how-to-build-an-app-for-the-oculus-go-from-start-to-finish-with-unity-cb72d931ddae"&gt;https://medium.com/inborn-experience/how-to-build-an-app-for-the-oculus-go-from-start-to-finish-with-unity-cb72d931ddae&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Passer en mode développeur&lt;/h1&gt;
&lt;p&gt;Pour que votre casque accepte des applications ne venant pas du store, il faut le passer en mode développeur.&lt;/p&gt;
&lt;p&gt;Pour cela, il faut se créer un compte développeur, gratuit, ici &lt;a href="https://dashboard.oculus.com/"&gt;https://dashboard.oculus.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Il faudra également faire “créer une organisation”.&lt;/p&gt;
&lt;p&gt;Il faudra ensuite aller sur votre smartphone dans l'application mobile associée à votre casque, et activer le mode développeur (paramètres &amp;gt; cliquez sur le chevron à droite de votre casque &amp;gt;  autres paramètres &amp;gt; paramètres avancés &amp;gt; Mode développeur).&lt;/p&gt;
&lt;p&gt;Enfin, en mettant le casque sur la tête lors de la première installation, un message vous demandera si vous faites bien confiance à cet ordinateur.&lt;/p&gt;
&lt;h1&gt;Débugger sur Oculus Quest&lt;/h1&gt;
&lt;p&gt;Si vous avez installé Android Studio, les commandes principales :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adb logcat -s Unity&lt;/code&gt; permettra d’obtenir les log Unity&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adb logcat -s VrApi&lt;/code&gt;permettra d’obtenir les log brut du framerate (sur Oculus Quest, il faut viser un 72 FPS quasi permanent : se téléporter, ou un chargement peut autoriser de baisser un peu pendant quelques frames, mais ça doit rester très rare pour ne pas rendre malade l’utilisateur)&lt;/p&gt;
&lt;p&gt;adb permet également d’avoir des info plus précises sur la consommation mémoire. Sur ce sujet : &lt;a href="https://developer.android.com/studio/command-line/dumpsys#meminfo"&gt;https://developer.android.com/studio/command-line/dumpsys#meminfo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Si vous n’avez pas installé Android Studio, l’outil permettant de livrer une version de test, SideQuest, décrit plus bas, fournit quelques options de débuggage permettant d’accéder à logcat notamment.&lt;/p&gt;
&lt;h1&gt;Livrer/faire tester&lt;/h1&gt;
&lt;p&gt;Un build Oculus Quest est un .apk classique.&lt;/p&gt;
&lt;p&gt;Un &lt;code&gt;adb install&lt;/code&gt; permettra donc de l’installer si le casque est branché à l’ordinateur.&lt;/p&gt;
&lt;p&gt;Unity lui même en phase de build Android peut faire ce déploiement en choisissant Build and Run.&lt;/p&gt;
&lt;p&gt;Mais pour des personnes à qui on voudrait faire tester l'application et n’ayant pas d’environnement de développement, installer Android Studio (ou Unity), n’est pas vraiment une solution.&lt;/p&gt;
&lt;p&gt;Il existe pour cela une application très pratique, s’appelant Sidequest : &lt;a href="https://sidequestvr.com/"&gt;https://sidequestvr.com/&lt;/a&gt;
Sachant qu’il faudra tout de même que votre testeur crée un compte développeur, mais le site ré-explique tout ici : &lt;a href="https://sidequestvr.com/setup-howto"&gt;https://sidequestvr.com/setup-howto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pour plus d'informations: &lt;a href="https://developer.oculus.com/blog/introducing-app-lab-a-new-way-to-distribute-oculus-quest-apps/?utm_source=social&amp;amp;utm_medium=ofd-tw"&gt;https://developer.oculus.com/blog/introducing-app-lab-a-new-way-to-distribute-oculus-quest-apps/?utm_source=social&amp;amp;utm_medium=ofd-tw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Suite du tutorial: &lt;a href="blog.poivre.name/oculus-quest-vr-intro-4.html"&gt;Partie 4 - Système de grab "from scratch"&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/gizmhail/gizmhail.github.io/issues/3"&gt;Accès aux commentaires&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="VR"></category><category term="Oculus Quest"></category><category term="VR"></category><category term="XR"></category><category term="Tutorial"></category><category term="Development"></category><category term="Oculus quest Dev Intro"></category></entry><entry><title>Débuter en réalité virtuelle avec Unity et Oculus Quest - Mise en place du projet (partie 2)</title><link href="blog.poivre.name/oculus-quest-vr-intro-2.html" rel="alternate"></link><published>2021-01-21T23:15:00+01:00</published><updated>2021-01-21T23:15:00+01:00</updated><author><name>Gizmhail</name></author><id>tag:None,2021-01-21:blog.poivre.name/oculus-quest-vr-intro-2.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Cette seconde partie fait suite à l’&lt;a href="blog.poivre.name/oculus-quest-vr-intro-1.html"&gt;intro expliquant les choix hardware/logiciel de ce tutorial&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Nous allons mettre ici en place le projet, et le rendre compatible VR.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Couches d’une application VR&lt;/h1&gt;
&lt;p&gt;Il y a plusieurs couches à prendre en compte dans une application VR :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;le module s …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Cette seconde partie fait suite à l’&lt;a href="blog.poivre.name/oculus-quest-vr-intro-1.html"&gt;intro expliquant les choix hardware/logiciel de ce tutorial&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Nous allons mettre ici en place le projet, et le rendre compatible VR.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Couches d’une application VR&lt;/h1&gt;
&lt;p&gt;Il y a plusieurs couches à prendre en compte dans une application VR :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;le module s’assurant que notre casque est supporté dans Unity&lt;/li&gt;
&lt;li&gt;la détection de la position des casques/contrôleurs&lt;/li&gt;
&lt;li&gt;la stack d’intéraction : comment gérer le fait d’attraper des objets, se déplacer/téléporter, avoir des pointeurs, interagir avec l’UI, animer les mains, …&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pour le 1), nous allons dans la mise en place du projet installer le XR Plug-in system, et son plugin Oculus. Il y a d’autres choix, suivant le hardware et les versions d’Unity, mais celui-là semble être le plus pédagogique pour ce que sera à l’avenir la VR dans Unity.&lt;/p&gt;
&lt;p&gt;Pour le 2), dans cette partie, nous ferons ici un choix très simple, afin d’avoir le plus grand contrôle sur ce que l’on fait pour bien comprendre.&lt;/p&gt;
&lt;p&gt;Pour le 3), nous allons initier ici le projet comme si on voulait tout faire à la main (ce qui est assez pédagogique), et donc juste s’intéresser à savoir quand les boutons du contrôleur sont enfoncés.&lt;/p&gt;
&lt;p&gt;Je proposerai certainement dans un article ultérieur une alternative pour le 2) et 3) qui permet d’avoir un environnement riche très rapidement, mais avec un contrôle moins complet.&lt;/p&gt;
&lt;h1&gt;Mise en place du projet&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Création d’un projet dans Unity : choisir le template de projet “3D”&lt;/li&gt;
&lt;li&gt;Aller dans Project Settings &amp;gt; XR Plugin Management, et cliquer sur “Install XR Plugin Management”&lt;/li&gt;
&lt;li&gt;Plug-in provider : cocher “Oculus”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="alt_text" src="images/oculus-quest-vr-intro-2-1.png" title="image_tooltip"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Si vous comptez utiliser git avec votre projet, je vous invite à utilise un fichier .gitignore de ce type, pour éviter de tracker tous les fichiers générés/temporaires : &lt;a href="https://github.com/github/gitignore/blob/master/Unity.gitignore"&gt;https://github.com/github/gitignore/blob/master/Unity.gitignore&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Suivi du casques et des mains&lt;/h1&gt;
&lt;p&gt;Il existe plusieurs manières de préparer une scène pour détecter votre casque VR, et ses contrôleurs :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;utiliser les composants simples TrackedPoseDriver : c’est ce que nous allons voir ici, pour montrer ce qu’on peut avoir en quelques clics&lt;/li&gt;
&lt;li&gt;utiliser le package XR Interaction Toolkit : c’est probablement une solution d’avenir, car géré par Unity directement. Cependant elle est encore en phase de prototype, donc on essuie de fait les plâtres en se basant dessus en ce moment&lt;/li&gt;
&lt;li&gt;utiliser un SDK dédié à un matériel, Oculus Integration ou SteamVR par exemple&lt;/li&gt;
&lt;li&gt;utiliser manuellement les appels à un InputDevice du module UnityEngine.XR (et tout refaire ce que font les exemples précédents à la main donc, mais avec un contrôle complet)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La solution que l’on va donc utiliser ici se base sur le composant TrackedPoseDriver.&lt;/p&gt;
&lt;p&gt;Il permet de dire qu’un GameObject prend comme position relative à son parent la position dans la réalité d’une pièce de hardware VR (casque, contrôleur, …)&lt;/p&gt;
&lt;h1&gt;Préparation de la scène&lt;/h1&gt;
&lt;h2&gt;Caméra&lt;/h2&gt;
&lt;p&gt;Sur une scène neuve (avec vraiment aucune manipulation après sa création), il y a un moyen très rapide de placer correctement le TrackedPoseDriver faisant que la caméra suive la position de votre tête :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sélectionner l’objet Main Caméra&lt;/li&gt;
&lt;li&gt;Clic-droit dessus &amp;gt; XR &amp;gt; Concert main camera to XR Rig&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Cela crée un ensemble d’objet de base, XR Rig, incluant la caméra et son TrackedposeDriver.&lt;/p&gt;
&lt;p&gt;&lt;img alt="alt_text" src="images/oculus-quest-vr-intro-2-2.png" title="image_tooltip"&gt;&lt;/p&gt;
&lt;p&gt;Cela rajoute en “bonus” un composant CameraOffset permettant de gérer comment est calculée la hauteur du casque par rapport au sol.&lt;/p&gt;
&lt;p&gt;Le défaut de cette solution est que la moindre modification sur la scène l'empêche de marcher.&lt;/p&gt;
&lt;p&gt;Mais manuellement, pour obtenir quelque chose de proche, il suffit en fait de :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ajouter un composant TrackedPoseDriver sur le GameObject contenant la caméra.&lt;/li&gt;
&lt;li&gt;mettre dans device : Generic XR Device&lt;/li&gt;
&lt;li&gt;mettre dans Pose source : Center eye&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Attention, si vous voulez par code déplacer l’utilisateur (téléportation, véhicule), il faut que votre caméra soit dans un objet parent, qui sera l’objet que vous déplacerez. Dans le cas du système automatisé décrit en début de chapitre, l’object XRRig généré est celui à déplacer.&lt;/p&gt;
&lt;h2&gt;Contrôleurs&lt;/h2&gt;
&lt;p&gt;Pour suivre les contrôleurs VR, pour chaque main :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;créez un objet vide&lt;/li&gt;
&lt;li&gt;ajoutez un Tracked pose driver&lt;/li&gt;
&lt;li&gt;en device, choisissez Generic XR Controller&lt;/li&gt;
&lt;li&gt;en Pose source, choisir la main qui nous intéresse&lt;/li&gt;
&lt;li&gt;pour “voir la main”, pensez à ajouter en fils de cet objet quelque chose de visible, comme un cube&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="alt_text" src="images/oculus-quest-vr-intro-2-3.png" title="image_tooltip"&gt;&lt;/p&gt;
&lt;h1&gt;Tester en direct&lt;/h1&gt;
&lt;p&gt;Si vous avez un casque branché sur votre PC (un casque PC, ou un Oculus Quest branché avec un câble de type Link), quand vous appuierez sur play dans l’éditeur Unity, en quelques secondes, votre application se lancera dans votre casque, et vous pourrez toujours la manipuler dans l’éditeur en direct.&lt;/p&gt;
&lt;h1&gt;Connaître l’état des boutons grab/trigger des contrôleurs&lt;/h1&gt;
&lt;p&gt;Il y a également plusieurs solutions pour obtenir l’état des boutons sur Unity.&lt;/p&gt;
&lt;p&gt;Mais, dans l’idée de viser l’état de l’art actuel, la nouvelle solution poussée par Unity est l’utilisation de l’Input System Package et d’input actions.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Remarque : si vous voulez utiliser la manière plus ancienne  de déterminer les boutons préssés car vous y êtes habitué, cette page vous donnera les id de boutons/axes dans l’ancien système : &lt;a href="https://docs.unity3d.com/2019.2/Documentation/Manual/OculusControllers.html"&gt;https://docs.unity3d.com/2019.2/Documentation/Manual/OculusControllers.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Pour activer l’Input Manager:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Installer l’Input System&lt;ul&gt;
&lt;li&gt;Window &amp;gt; Package Manager&lt;/li&gt;
&lt;li&gt;en haut, choisir Packages : Unity registry&lt;/li&gt;
&lt;li&gt;Choisir Input system, install&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Choisir l’Input System comme système d’Input&lt;ul&gt;
&lt;li&gt;Edit &amp;gt; Project settings &amp;gt; PLayer &amp;gt; Other settings:configuration &amp;gt; Active Input Handling : Input System Package (new)&lt;/li&gt;
&lt;li&gt;(Unity redémarre)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maintenant, voici un petit script utilisant une action :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;UnityEngine.InputSystem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;XRControllerState&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;InputAction&lt;/span&gt; &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Awake&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;performed&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;OnGrabStart&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;canceled&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;OnGrabEnd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;grabAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Enable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGrabStart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CallbackContext&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;OnGrabStart&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGrabEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputAction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CallbackContext&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;OnGrabEnd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dans l’inspecteur, quand vous ajoutez ce composant sur la main gauche par exemple, vous pouvez y ajouter une action pour détecter quand on appuie sur le bouton pour attraper, le grip :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sur “Grab action”, cliquez sur +&lt;/li&gt;
&lt;li&gt;Choisir dans le menu “Add binding”&lt;/li&gt;
&lt;li&gt;Double-cliquez sur “No binding”&lt;/li&gt;
&lt;li&gt;Dans Path, choissir XR Controller &amp;gt; Oculus Touch Contorller &amp;gt; (Oculus Touch controller (Left hand) &amp;gt; gripPressed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;De la même manière, l’action triggerPressed fournira elle l’activation de la gâchette avant.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Suite du tutorial: &lt;a href="blog.poivre.name/oculus-quest-vr-intro-3.html"&gt;Partie 3 - builder pour le casque en autonome&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/gizmhail/gizmhail.github.io/issues/2"&gt;Accès aux commentaires&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="VR"></category><category term="Oculus Quest"></category><category term="VR"></category><category term="XR"></category><category term="Tutorial"></category><category term="Development"></category><category term="Oculus quest Dev Intro"></category></entry><entry><title>Débuter en réalité virtuelle avec Unity et Oculus Quest - Intro (partie 1)</title><link href="blog.poivre.name/oculus-quest-vr-intro-1.html" rel="alternate"></link><published>2021-01-20T23:00:00+01:00</published><updated>2021-01-20T23:00:00+01:00</updated><author><name>Gizmhail</name></author><id>tag:None,2021-01-20:blog.poivre.name/oculus-quest-vr-intro-1.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Vous avez eu pour Noël un Oculus Quest 2, et fasciné par Beat Saber, Superhot, Tetris Effect et autres Titans of space, vous rêveriez vous aussi de faire votre appli VR.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pas de souci, c’est à portée de clavier !&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Et si savoir que vous pourrez crafter de la VR …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Vous avez eu pour Noël un Oculus Quest 2, et fasciné par Beat Saber, Superhot, Tetris Effect et autres Titans of space, vous rêveriez vous aussi de faire votre appli VR.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pas de souci, c’est à portée de clavier !&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Et si savoir que vous pourrez crafter de la VR est à 2 doigts de vous faire chuter dans un achat en VR, l’aventure vous attend ;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pour cette première partie, je vous donne quelques éléments de contexte sur les choix de ce tutorial, avant de rentrer dans la pratique par la suite.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Hardware&lt;/h1&gt;
&lt;p&gt;La plupart des explications que nous verrons par la suite sont pertinentes pour différents casques autonomes (Oculus Quest, Oculus Quest 2, HTC Vive Focus Plus), ainsi que pour la plupart des casques PC (Oculus Rift, HTC Vive, Valve Index, …).  &lt;/p&gt;
&lt;p&gt;Si j’oriente un peu cette explication sur l'Oculus Quest 2, c’est qu’actuellement, pour faire de la réalité virtuelle, l’Oculus Quest 2 est un appareil extrêmement adapté(*) :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;il est relativement peu cher : 350€ (**)&lt;/li&gt;
&lt;li&gt;on est sur un casque de qualité, captant très bien la position de l’utilisateur dans l’espace, ce qui évite d’être malade(***) ,&lt;/li&gt;
&lt;li&gt;il est autonome, et ne nécessite donc pas un ordinateur puissant pour faire tourner vos applications...&lt;/li&gt;
&lt;li&gt;...mais il peut AUSSI servir de casque pour PC, produisant le meilleur des 2 mondes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(*) : il y a quand même un (très gros) souci dans ce tableau idyllique : Facebook, qui a racheté Oculus, oblige pour le moment de lier son compte Facebook au casque. C’est gênant, très gênant, je suis d’accord. Si éthiquement, cela vous pose souci, comme je disais, il y a des alternatives, mais un peu plus chères. Si vous êtes intéressé, on pourra discuter de ces alternatives dans les commentaires.&lt;/p&gt;
&lt;p&gt;(**) : même si je vous conseille pour le confort de rajouter une sangle Elite et un long cable Link pour brancher au PC, il existe des alternatives non officielles pour ce câble - encore un sujet de discussion possible si besoin :) (si vous êtes une combinaison de radins/pressés/curieux, vous pouvez regarder cet article : &lt;a href="https://www.etr.fr/actualite/7624-test-oculus-link-le-cable-officiel-est-il-vraiment-utile-avec-l-oculus-quest-2.html"&gt;https://www.etr.fr/actualite/7624-test-oculus-link-le-cable-officiel-est-il-vraiment-utile-avec-l-oculus-quest-2.html&lt;/a&gt;, l’équivalent )&lt;/p&gt;
&lt;p&gt;(***) : c’est un casque 6 DoF, 6 degrés de liberté, pas un casque 3DoF comme ceux qu’on utilise avec des téléphones portables (cardboard, …), et qui eux entraînent souvent des nausées fortes&lt;/p&gt;
&lt;p&gt;Attention cependant, si votre ordi est vraiment très peu puissant, vous aurez probablement des difficultés à tester votre logiciel en live en mode développeur, sur votre ordinateur. Vous pourrez le tester en buildant à chaque fois, mais l’expérience de dév, très agréable en VR sur Unity, deviendra là bien moins fluide.&lt;/p&gt;
&lt;p&gt;Il y a cependant un XR Device Simulator qui pourrait vous aider si c’est votre cas, n’hésitez pas à me contacter si vous voulez creuser cette piste.&lt;/p&gt;
&lt;h1&gt;Logiciel&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Unity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Il existe différents moteurs 3D nous permettant de faire de la VR, les plus connus étant Unity, Unreal, et récemment (et en open source) Godot.&lt;/p&gt;
&lt;p&gt;Tout 3 permettent, plus ou moins bien, de faire de la VR.&lt;/p&gt;
&lt;p&gt;Mais aujourd’hui, pour quelqu’un ayant peu de connaissances préalables, Unity est probablement l’environnement le plus pertinent pour se mettre à la VR.&lt;/p&gt;
&lt;p&gt;Pour installer Unity, téléchargez Unity Hub &lt;a href="https://store.unity.com/download-nuo"&gt;https://store.unity.com/download-nuo&lt;/a&gt;, et choisissez d’installer la version 2020.2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XR Plug-in management&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Comme cette présentation est une introduction, je vais vous orienter sur les technos à venir, et notamment sur les dernières versions d’Unity, Unity 2020.2.&lt;/p&gt;
&lt;p&gt;Il faut cependant savoir que les versions d’Unity cohabitent assez longuement (il est assez normal d’encore utiliser Unity 2019 aujourd’hui -  c’est d’ailleurs la seule version avec une LTS actuellement).&lt;/p&gt;
&lt;p&gt;Précédemment, le support de la VR était buildé “en dur” dans Unity. Depuis Unity 2019, ils tentent d’aller vers une architecture plus modulaire du moteur Unity, avec différents packages optionnels. Il existait donc 2 manières de supporter la VR en 2019, l’ancien support VR, disparu en version 2020, et le nouveau, que j’aborde ici, le XR Plug-in management system&lt;/p&gt;
&lt;p&gt;Dans ce nouveau système, les casques HTC Vive n’étaient initialement pas supportés; ils le sont, en beta, depuis la 2020.2 (d’où ce choix de version précise ici)&lt;/p&gt;
&lt;p&gt;Ce support se fait par un module intéressant, OpenXR, qui a la velléité de pouvoir supporter tous les casques AR et VR, OpenXR étant un standard visant ce but.&lt;/p&gt;
&lt;p&gt;Cependant, de part ce caractère expérimental, si vous voulez jouer avec un casque HTC vive ou Valve Index, il est tout à fait raisonnable de rester sur Unity 2019 et d’utiliser la stack SteamVR : &lt;a href="https://assetstore.unity.com/packages/tools/integration/steamvr-plugin-32647#description"&gt;https://assetstore.unity.com/packages/tools/integration/steamvr-plugin-32647#description&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Si c’est votre cas, n’hésitez pas à en parler dans les commentaires, cette stack est très facile d’usage également.&lt;/p&gt;
&lt;p&gt;De la même manière, dans l’idée de faire un tutorial couvrant à terme tous les casques une fois le XR Plug-in management system mature, je ne parle pas spécialement du SDK spécifique à Oculus, &lt;a href="https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022"&gt;https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022&lt;/a&gt;, mais il est également disponible, et est un choix tout à fait pertinent et agréable à utiliser pour développer sur Oculus Quest.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Suite du tutorial: &lt;a href="blog.poivre.name/oculus-quest-vr-intro-2.html"&gt;Partie 2 - Mise en place du projet&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://github.com/gizmhail/gizmhail.github.io/issues/1"&gt;Accès aux commentaires&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><category term="VR"></category><category term="Oculus Quest"></category><category term="VR"></category><category term="XR"></category><category term="Tutorial"></category><category term="Development"></category><category term="Oculus quest Dev Intro"></category></entry></feed>